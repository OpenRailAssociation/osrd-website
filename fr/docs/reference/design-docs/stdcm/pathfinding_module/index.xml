<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Module de recherche de sillons on OSRD</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/</link><description>Recent content in Module de recherche de sillons on OSRD</description><generator>Hugo</generator><language>fr</language><atom:link href="https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/index.xml" rel="self" type="application/rss+xml"/><item><title>Parcours de l'infrastructure</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/infrastructure_exploration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/infrastructure_exploration/</guid><description>&lt;p>La première chose à définir est &lt;em>comment un train se déplace sur l&amp;rsquo;infrastructure&lt;/em>,
sans prendre en compte les conflits pour l&amp;rsquo;instant.&lt;/p>
&lt;p>On a besoin d&amp;rsquo;une manière de définir et d&amp;rsquo;énumérer les différents chemins
possibles et de parcourir l&amp;rsquo;infrastructure, avec plusieurs contraintes :&lt;/p>
&lt;ol>
&lt;li>Le chemin doit être compatible avec le matériel roulant donné
(électrification, gabarit, systèmes de signalisation)&lt;/li>
&lt;li>À n&amp;rsquo;importe quel point, on doit être en mesure d&amp;rsquo;accéder aux propriétés
du chemin depuis le point de départ jusqu&amp;rsquo;au point considéré.
Cela inclus les routes et les cantons.&lt;/li>
&lt;li>Dans certains cas, on doit savoir où le train ira &lt;em>après&lt;/em>
le point actuellement évalué (pour une détection de conflits correcte).&lt;/li>
&lt;/ol>
&lt;p>Pour répondre à ce besoin, une classe &lt;code>InfraExplorer&lt;/code> a été implémentée.
Elle utilise les cantons (section de signal en signal) comme subdivision
principale.
Elle est composée de 3 sections : le canton courant, les prédécesseurs,
et les cantons suivants.&lt;/p></description></item><item><title>Détection de conflits</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/conflict_detection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/conflict_detection/</guid><description>&lt;p>Maintenant qu&amp;rsquo;on sait quels chemins peuvent être utilisés,
on doit déterminer à quel moment ces chemins sont libres.&lt;/p>
&lt;p>La documentation (en anglais seulement)
de la détection de conflits explique comment elle est réalisée
en interne. Pour résumer, un train est en conflit avec un autre
quand il observe un signal lui indiquant de ralentir.
Dans notre cas, une solution où cette situation se produit
est considérée comme invalide, le train doit arriver
au signal donné plus tard (ou plus tôt) quand le signal
n&amp;rsquo;est plus contraignant.&lt;/p></description></item><item><title>Représentation de l'espace de solutions</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/graph_representation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/graph_representation/</guid><description>&lt;h4 id="principe-général">Principe général&lt;/h4>
&lt;p>Le problème reste une recherche de graphe. En représentant
l&amp;rsquo;espace de solution sous forme de graphe, il est possible de réutiliser
nos outils déjà existants de recherche de chemin.&lt;/p>
&lt;p>Le &lt;em>graphe produit&lt;/em> de la position, du temps, et de la vitesse est utilisé.
Autrement dit, chaque élément du graphe contient (entre autres) ces
3 variables.&lt;/p>
&lt;p>Chaque arête du graphe est calculée avec un
&lt;a href="https://osrd.fr/fr/docs/explanation/running_time_calculation/" title="calcul de marche">calcul de marche&lt;/a>
pour connaître l&amp;rsquo;évolution de la vitesse et de la position dans le temps.&lt;/p></description></item><item><title>Discontinuités et retours en arrière</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/backtracking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/backtracking/</guid><description>&lt;h4 id="le-problème-des-discontinuités">Le problème des discontinuités&lt;/h4>
&lt;p>Au moment d&amp;rsquo;explorer une arête du graphe, on effectue un calcul de
marche pour connaître l&amp;rsquo;évolution de la vitesse.
Mais il n&amp;rsquo;est pas possible de voir plus loin que l&amp;rsquo;arête en question,
ce qui est gênant pour calculer les courbes de freinages qui peuvent
nécessiter de commencer à freiner plusieurs kilomètres avant l&amp;rsquo;arrivée.&lt;/p>
&lt;p>&lt;img src="https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/backtracking/discontinuity.png" alt="Discontinuité">&lt;/p>
&lt;blockquote>
&lt;p>Cet exemple illustre le problème : par défaut
la première arête est explorée en allant à la vitesse maximale.
C&amp;rsquo;est seulement en explorant la seconde arête que la destination devient visible,
sans que la distance restante soit suffisante pour s&amp;rsquo;arrêter.&lt;/p></description></item><item><title>Contourner les conflits</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/conflict_avoidance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/conflict_avoidance/</guid><description>&lt;p>En explorant le graphe, il arrive souvent de tomber sur des situations
qui mèneraient à des conflits. Il faut être en mesure de rajouter du délai
pour les éviter.&lt;/p>
&lt;h4 id="décalage-du-temps-de-départ">Décalage du temps de départ&lt;/h4>
&lt;p>Dans les paramètres de l&amp;rsquo;algorithme, le temps de départ est donné
sous la forme d&amp;rsquo;une fenêtre : un temps de départ au plus tôt et au plus tard.
Tant que c&amp;rsquo;est possible, il est toujours préférable de décaler le temps
de départ pour éviter les conflits.&lt;/p></description></item><item><title>Marge de régularité</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/standard_allowance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/standard_allowance/</guid><description>&lt;p>Une des fonctionnalités qui doit être supportée par STDCM est la
&lt;a href="https://osrd.fr/fr/docs/explanation/running_time_calculation/allowances/" title="marge de régularité">marge de régularité&lt;/a>.
L&amp;rsquo;utilisateur doit pouvoir indiquer une valeur
de marge, exprimée en fonction de la distance ou du temps de parcours,
et cette marge doit être ajoutée au trajet.&lt;/p>
&lt;blockquote>
&lt;p>Par exemple : l&amp;rsquo;utilisateur peut indiquer une marge de 5 minutes au
100km. Sur un trajet de 42km, un trajet de 10 minutes au plus rapide
doit maintenant durer 12 minutes et 6 secondes.&lt;/p></description></item><item><title>Détails d'implémentation</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/implementation_details/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/implementation_details/</guid><description>&lt;p>Cette page précise certains détails d&amp;rsquo;implémentation.
Sa lecture n&amp;rsquo;est pas nécessaire pour comprendre les principes
généraux, mais peut aider avant de se plonger dans le code.&lt;/p>
&lt;h4 id="stdcmedgebuilder">STDCMEdgeBuilder&lt;/h4>
&lt;p>Cette classe est utilisée pour simplifier la création d&amp;rsquo;instances de &lt;code>STDCMEdge&lt;/code>,
les arêtes du graphe. Celles-ci contiennent de nombreux attributs,
la plupart pouvant être déterminés en fonction du contexte (comme
le nœud précédent). La classe &lt;code>STDCMEdgeBuilder&lt;/code> permet de rendre
certains attributs optionnels et en calcule d&amp;rsquo;autres.&lt;/p></description></item></channel></rss>