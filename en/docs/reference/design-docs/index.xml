<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design documents on OSRD</title><link>https://osrd.fr/en/docs/reference/design-docs/</link><description>Recent content in Design documents on OSRD</description><generator>Hugo</generator><language>en</language><atom:link href="https://osrd.fr/en/docs/reference/design-docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Conflict detection</title><link>https://osrd.fr/en/docs/reference/design-docs/conflict-detection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/en/docs/reference/design-docs/conflict-detection/</guid><description>&lt;div class="pageinfo pageinfo-warning">
&lt;p>This document is a work in progress&lt;/p>

&lt;/div>

&lt;p>Conflict detection is the process of looking for timetable conflicts.
A timetable conflict is any predictable condition which disrupts planned operations.
Planned operations can be disrupted if a train is slowed down, prevented from proceeding, or delayed.&lt;/p>
&lt;p>One of the core features of OSRD is the ability to automatically detect some conflicts:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>spacing conflicts&lt;/strong>: insufficient spacing between trains sharing the same path&lt;/li>
&lt;li>&lt;strong>routing conflicts&lt;/strong>: insufficient spacing between trains with intersecting paths&lt;/li>
&lt;/ul>
&lt;p>Some other kinds of conflicts may be detected &lt;em>later on&lt;/em>:&lt;/p></description></item><item><title>Timetable v2</title><link>https://osrd.fr/en/docs/reference/design-docs/timetable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/en/docs/reference/design-docs/timetable/</guid><description>&lt;p>&lt;img src="https://osrd.fr/en/docs/reference/design-docs/timetable/timetable.svg" alt="Test">&lt;/p>
&lt;h2 id="design-decisions">Design decisions&lt;/h2>
&lt;p>Some major changes were made between our first version of the timetable and the new one:&lt;/p>
&lt;ul>
&lt;li>Isolate the timetable table. It can be used in a scenario or in other contexts&lt;/li>
&lt;li>Have a soft reference from train schedule to rolling stock (to be able to create a train schedule with unknown rolling stock)&lt;/li>
&lt;li>Consider path and simulation output as cache (that don&amp;rsquo;t require to be stored in DB)&lt;/li>
&lt;li>We can compute pathfinding without having to store data&lt;/li>
&lt;li>All input needed to compute a path is stored in the train schedule (we can recompute it if needed)&lt;/li>
&lt;li>All input needed to run a simulation is stored in the train schedule (we can recompute it if needed)&lt;/li>
&lt;/ul>
&lt;h1 id="train-schedule-v2">Train schedule v2&lt;/h1>
&lt;h2 id="requirements">Requirements&lt;/h2>
&lt;ul>
&lt;li>&lt;code>front&lt;/code>: easy to keep consistent during edition&lt;/li>
&lt;li>&lt;code>front&lt;/code>: intermediate invalid states than can be reached during edition have to be encodable&lt;/li>
&lt;li>&lt;code>front&lt;/code>: when deleting a waypoint that is referenced by margins, the position of the deleted waypoint within the path must be preserved until the situation is resolved&lt;/li>
&lt;li>&lt;code>import&lt;/code>: path waypoint locations can be specified using UIC operational point codes&lt;/li>
&lt;li>&lt;code>import&lt;/code>: support fixed scheduled arrival times at stops and arbitrary points&lt;/li>
&lt;li>&lt;code>import&lt;/code> &lt;code>edition&lt;/code>: train schedules must be self-contained: they cannot be described using the result of pathfinding or simulations&lt;/li>
&lt;/ul>
&lt;h2 id="design-decisions-1">Design decisions&lt;/h2>
&lt;h3 id="path-waypoints-have-an-identity">Path waypoints have an identity&lt;/h3>
&lt;p>At some point in the design process, the question was raised of whether to reference location of stops and margin transitions by name, or by value. That is, should stops hold the index of the waypoint where the stop occurs, or a description of the location where the stop occurs?&lt;/p></description></item><item><title>Scalable async RPC</title><link>https://osrd.fr/en/docs/reference/design-docs/scalable-async-rpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/en/docs/reference/design-docs/scalable-async-rpc/</guid><description>&lt;p>TODO: create another document describing RPC interactions between core and editoast&lt;/p>
&lt;h2 id="context-and-requirements">Context and requirements&lt;/h2>
&lt;p>Without this proposal, editoast directly makes calls to core using http.
Using k8s, if multiple core workers are started, requests are randomly
distributed to core workers.&lt;/p>
&lt;p>This architecture brings a number of issues:&lt;/p>
&lt;ul>
&lt;li>To respond to a request, the core worker need to hold the request&amp;rsquo;s full infrastructure in memory.
Workers do not have enough memory to hold all infrastructures in memory.
Requests thus need to be routed to core workers specialized by infrastructure, which cannot be easily done using http.&lt;/li>
&lt;li>If too many requests are dispatched to a busy core worker, they will just time out.&lt;/li>
&lt;li>There is no easy way to scale up the number of workers to react to increased load.&lt;/li>
&lt;li>Because calls need to complete within the timeout of the client&amp;rsquo;s http requests,
the system falls apart when latency increases due to load.&lt;/li>
&lt;/ul>
&lt;p>This proposal intends to address these issues by introducing an RPC system which:&lt;/p></description></item></channel></rss>