<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Train slot search module on OSRD</title><link>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/</link><description>Recent content in Train slot search module on OSRD</description><generator>Hugo</generator><language>en</language><atom:link href="https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/index.xml" rel="self" type="application/rss+xml"/><item><title>Infrastructure exploration</title><link>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/infrastructure_exploration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/infrastructure_exploration/</guid><description>&lt;p>The first thing we need to define is &lt;em>how we move through the infrastructure&lt;/em>,
without dealing with conflicts yet.&lt;/p>
&lt;p>We need a way to define and enumerate the different possible paths and
explore the infrastructure graph, with several constraints:&lt;/p>
&lt;ol>
&lt;li>The path must be compatible with the given rolling stock
(loading gauge / electrification / signaling system)&lt;/li>
&lt;li>At any point, we need to access path properties from its start up to the
considered point. This includes block and route lists.&lt;/li>
&lt;li>We sometimes need to know where the train will go &lt;em>after&lt;/em> the
point currently being evaluated, for proper conflict detection&lt;/li>
&lt;/ol>
&lt;p>To do this, we have defined the class &lt;code>InfraExplorer&lt;/code>. It uses blocks
(sections from signal to signal) as a main subdivision.
It has 3 sections: the current block, predecessors, and a &amp;ldquo;lookahead&amp;rdquo;.&lt;/p></description></item><item><title>Conflict detection</title><link>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/conflict_detection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/conflict_detection/</guid><description>&lt;p>Once we know what paths we can use, we need to know when they
can actually be used.&lt;/p>
&lt;p>The &lt;a href="https://osrd.fr/en/docs/reference/design-docs/conflict-detection/" title="documentation">documentation&lt;/a>
of the conflict detection module explains how it&amp;rsquo;s done internally.
Generally speaking, a train is in conflict when it has to slow down
because of a signal. In our case, that means the solution would not
be valid, we need to arrive later (or earlier) to see the signal
when it&amp;rsquo;s not restrictive anymore.&lt;/p></description></item><item><title>Encoding the solution space</title><link>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/graph_representation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/graph_representation/</guid><description>&lt;h4 id="general-principle">General principle&lt;/h4>
&lt;p>The problem is still a pathfinding problem in a given graph.
Once the problem is encoded as a graph search, it is possible to reuse
our existing tools for this purpose.&lt;/p>
&lt;p>We consider the &lt;em>product graph&lt;/em> of position, time, and speed.
This means that every graph element contains these 3 variables
(among other things)&lt;/p>
&lt;p>Every graph edge is computed using
&lt;a href="https://osrd.fr/en/docs/explanation/running_time_calculation/" title="running-time calculation">running-time calculation&lt;/a>
to get speed and positions as functions of time.&lt;/p></description></item><item><title>Discontinuities and backtracking</title><link>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/backtracking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/backtracking/</guid><description>&lt;h4 id="the-discontinuity-problem">The discontinuity problem&lt;/h4>
&lt;p>When a new graph edge is visited, a simulation is run to evaluate
its speed. But it is not possible to see beyond the current edge.
This makes it difficult to compute braking curves, because
they can span over several edges.&lt;/p>
&lt;p>&lt;img src="https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/backtracking/discontinuity.png" alt="Discontinuity">&lt;/p>
&lt;blockquote>
&lt;p>This example illustrates the problem: by default
the first edge is explored by going at maximum speed.
The destination is only visible once the second edge is visited,
which doesn&amp;rsquo;t leave enough distance to stop.&lt;/p></description></item><item><title>Conflict avoidance</title><link>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/conflict_avoidance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/conflict_avoidance/</guid><description>&lt;p>While exploring the graph, it is possible to end up in locations that would
generate conflicts. They can be avoided by adding delay.&lt;/p>
&lt;h4 id="shifting-the-departure-time">Shifting the departure time&lt;/h4>
&lt;p>The departure time is defined as an interval in the module parameters:
the train can leave at a given time, or up to &lt;code>x&lt;/code> seconds later.
Whenever possible, delay should be added by shifting the departure time.&lt;/p>
&lt;blockquote>
&lt;p>for example : a train can leave between 10:00 et 11:00. Leaving
at 10:00 would cause a conflict, the train actually needs to enter the
destination station 15 minutes later. Making the train leave at
10:15 solves the problem.&lt;/p></description></item><item><title>Standard allowance</title><link>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/standard_allowance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/standard_allowance/</guid><description>&lt;p>The STDCM module must be usable with
&lt;a href="https://osrd.fr/en/docs/explanation/running_time_calculation/allowances/">standard allowances&lt;/a>.
The user can set an allowance value, expressed either as a function of
the running time or the travelled distance. This time must be added to the
running time, so that it arrives later compared to its fastest possible
running time.&lt;/p>
&lt;blockquote>
&lt;p>For example: the user can set a margin of 5 minutes per 100km.
On a 42km long path that would take 10 minutes at best,
the train should arrive 12 minutes and 6 seconds after leaving.&lt;/p></description></item><item><title>Implementation details</title><link>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/implementation_details/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/en/docs/reference/design-docs/stdcm/pathfinding_module/implementation_details/</guid><description>&lt;p>This page is about implementation details.
It isn&amp;rsquo;t necessary to understand general principles,
but it helps before reading the code.&lt;/p>
&lt;h4 id="stdcmedgebuilder">STDCMEdgeBuilder&lt;/h4>
&lt;p>This refers to
&lt;a href="https://github.com/OpenRailAssociation/osrd/blob/dev/core/src/main/kotlin/fr/sncf/osrd/stdcm/graph/STDCMEdgeBuilder.kt">this class&lt;/a>
in the project.&lt;/p>
&lt;p>This class is used to make it easier to create instances of
&lt;code>STDCMEdge&lt;/code>, the graph edges. Those contain many attributes,
most of which can be determined from the context (e.g. the
previous node).
The &lt;code>STDCMEdgeBuilder&lt;/code> class makes some parameters optional
and automatically computes others.&lt;/p></description></item></channel></rss>